{% extends 'base.html' %}

{% load static %}

{% block title %}
    Parking Slot Management
{% endblock title %}

{% block header %}
    <h1 class="mt-4 md:ml-5 pb-2 md:text-left text-center text-white font-bold text-4xl">Parking Slot Management</h1>
{% endblock header %}

{% block content %}
<section class="profile-information">
    <div class="p-5 bg-[#dcdbdb] min-h-screen">
        <div class="flex items-center gap-6 w-full mx-auto">
            <div class="w-full bg-white rounded-xl shadow-md overflow-hidden p-8 mb-6">
                <div id="initial-controls" class="flex flex-col sm:flex-row justify-between items-center gap-3 mb-8">
                    <h2 class="text-2xl font-bold text-gray-800">Parking Slot Management</h2>
                    <button id="start-edit" class="px-6 py-3 bg-[#7cd1f9] hover:bg-[#78cbf2] text-white rounded-lg transition-colors font-medium">
                        Edit Parking Layout
                    </button>
                </div>

                <div id="editing-controls" class="hidden flex-col sm:flex-row justify-between items-center gap-3 mb-8">
                    <h2 class="text-2xl font-bold text-gray-800">Editing Mode</h2>
                    <div class="flex flex-wrap gap-3">
                        <button id="add-slot" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors">
                            Add Slot
                        </button>
                        <button id="edit-slot" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-lg transition-colors">
                            Edit Slot
                        </button>
                        <button id="delete-slot" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors">
                            Delete Slot
                        </button>
                        <button id="save-changes" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">
                            Save Changes
                        </button>
                        <button id="cancel-edit" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-100 transition-colors">
                            Cancel
                        </button>
                    </div>
                </div>

                <div id="instructions" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-8 hidden">
                    <h3 class="font-semibold text-blue-800 mb-2">How to use:</h3>
                    <ul class="text-blue-700 text-sm list-disc list-inside space-y-1">
                        <li><span class="font-medium">Add:</span> Click and drag to draw bounding boxes</li>
                        <li><span class="font-medium">Edit:</span> Click to select, drag corners to resize</li>
                        <li><span class="font-medium">Delete:</span> Click on boxes to remove them</li>
                        <li><span class="font-medium">Save:</span> Click Save Changes to apply your modifications</li>
                    </ul>
                </div>

                <div class="bg-white rounded-lg overflow-hidden relative">
                    <div class="relative w-full">
                        <img id="parking-image" 
                             class="w-full h-auto block" 
                             src="{% static 'images/parkingallotment.jpg' %}" 
                             alt="Parking Layout"
                             style="display: block;">
                        <canvas id="bounding-canvas" class="absolute top-0 left-0 w-full h-full cursor-default"></canvas>
                    </div>
                    
                    <div id="mode-indicator" class="absolute top-4 left-4 bg-black bg-opacity-70 text-white px-3 py-2 rounded-lg text-sm font-medium hidden">
                        Mode: View
                    </div>

                    <div id="selected-info" class="absolute top-4 right-4 bg-black bg-opacity-70 text-white px-3 py-2 rounded-lg text-sm hidden">
                        Selected: <span id="selected-slot">None</span>
                    </div>
                </div>

                <div id="unsaved-warning" class="hidden mt-6 bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                    <div class="flex items-center gap-2">
                        <svg class="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                        <span class="text-yellow-700 font-medium">You have unsaved changes</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock content %}

{% block script %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const parkingImage = document.getElementById('parking-image');
    const canvas = document.getElementById('bounding-canvas');
    const ctx = canvas.getContext('2d');
    const modeIndicator = document.getElementById('mode-indicator');
    const selectedInfo = document.getElementById('selected-info');
    const selectedSlot = document.getElementById('selected-slot');
    const initialControls = document.getElementById('initial-controls');
    const editingControls = document.getElementById('editing-controls');
    const instructions = document.getElementById('instructions');
    const unsavedWarning = document.getElementById('unsaved-warning');
    
    const startEditBtn = document.getElementById('start-edit');
    const addButton = document.getElementById('add-slot');
    const editButton = document.getElementById('edit-slot');
    const deleteButton = document.getElementById('delete-slot');
    const saveButton = document.getElementById('save-changes');
    const cancelButton = document.getElementById('cancel-edit');
    
    let currentMode = 'view';
    let boundingBoxes = [];
    let originalBoxes = [];
    let currentBox = null;
    let isDrawing = false;
    let isResizing = false;
    let isMoving = false;
    let startX, startY;
    let selectedBoxIndex = -1;
    let resizeHandleIndex = -1;
    let imageWidth = 0;
    let imageHeight = 0;
    let hasUnsavedChanges = false;
    let scaleX = 1;
    let scaleY = 1;

    function setCanvasSize() {
        const imgRect = parkingImage.getBoundingClientRect();
        
        canvas.width = imgRect.width;
        canvas.height = imgRect.height;
        
        imageWidth = parkingImage.naturalWidth;
        imageHeight = parkingImage.naturalHeight;
        
        scaleX = imageWidth / imgRect.width;
        scaleY = imageHeight / imgRect.height;
        
        console.log('Image natural size:', imageWidth, 'x', imageHeight);
        console.log('Image displayed size:', imgRect.width, 'x', imgRect.height);
        console.log('Scale factors:', scaleX, scaleY);
        
        drawBoundingBoxes();
    }

    function screenToImageCoords(screenX, screenY) {
        const imgRect = parkingImage.getBoundingClientRect();
        
        const relativeX = screenX - imgRect.left;
        const relativeY = screenY - imgRect.top;
        
        return {
            x: Math.round(relativeX * scaleX),
            y: Math.round(relativeY * scaleY)
        };
    }

    function imageToScreenCoords(imageX, imageY) {
        const imgRect = parkingImage.getBoundingClientRect();
        
        return {
            x: Math.round(imageX / scaleX),
            y: Math.round(imageY / scaleY)
        };
    }

    function drawBoundingBoxes() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        boundingBoxes.forEach((box, index) => {
            const screenCoords = imageToScreenCoords(box.x, box.y);
            const screenWidth = box.width / scaleX;
            const screenHeight = box.height / scaleY;
            
            ctx.strokeStyle = index === selectedBoxIndex ? '#ff0000' : '#00aa00';
            ctx.lineWidth = index === selectedBoxIndex ? 3 : 2;
            ctx.strokeRect(screenCoords.x, screenCoords.y, screenWidth, screenHeight);
            
            ctx.fillStyle = index === selectedBoxIndex ? '#ff0000' : '#00aa00';
            ctx.font = '14px Arial';
            ctx.fillText(box.id, screenCoords.x + 5, screenCoords.y - 5);
            
            if (currentMode === 'edit' && index === selectedBoxIndex) {
                drawResizeHandles(screenCoords.x, screenCoords.y, screenWidth, screenHeight);
            }
        });
        
        if (currentBox && isDrawing) {
            ctx.strokeStyle = '#0000ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(currentBox.startScreenX, currentBox.startScreenY, currentBox.width, currentBox.height);
        }
    }

    function drawResizeHandles(x, y, width, height) {
        const handleSize = 8;
        const handles = [
            { x: x - handleSize/2, y: y - handleSize/2, type: 'top-left' },
            { x: x + width - handleSize/2, y: y - handleSize/2, type: 'top-right' },
            { x: x - handleSize/2, y: y + height - handleSize/2, type: 'bottom-left' },
            { x: x + width - handleSize/2, y: y + height - handleSize/2, type: 'bottom-right' }
        ];
        
        ctx.fillStyle = '#ff0000';
        handles.forEach(handle => {
            ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
        });
    }

    function getResizeHandles(x, y, width, height) {
        const handleSize = 8;
        return [
            { x: x - handleSize/2, y: y - handleSize/2, type: 'top-left' },
            { x: x + width - handleSize/2, y: y - handleSize/2, type: 'top-right' },
            { x: x - handleSize/2, y: y + height - handleSize/2, type: 'bottom-left' },
            { x: x + width - handleSize/2, y: y + height - handleSize/2, type: 'bottom-right' }
        ];
    }

    function isPointInHandle(x, y, handle) {
        const handleSize = 8;
        return x >= handle.x && x <= handle.x + handleSize && 
               y >= handle.y && y <= handle.y + handleSize;
    }

    function isPointInBox(screenX, screenY, box) {
        const screenCoords = imageToScreenCoords(box.x, box.y);
        const screenWidth = box.width / scaleX;
        const screenHeight = box.height / scaleY;
        
        return screenX >= screenCoords.x && screenX <= screenCoords.x + screenWidth && 
               screenY >= screenCoords.y && screenY <= screenCoords.y + screenHeight;
    }

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);

    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);

    function handleMouseDown(e) {
        if (currentMode === 'view') return;
        handlePointerDown(e.clientX, e.clientY);
    }

    function handleTouchStart(e) {
        if (currentMode === 'view') return;
        e.preventDefault();
        const touch = e.touches[0];
        handlePointerDown(touch.clientX, touch.clientY);
    }

    function handlePointerDown(clientX, clientY) {
        const imgRect = parkingImage.getBoundingClientRect();
        const screenX = clientX - imgRect.left;
        const screenY = clientY - imgRect.top;
        const imageCoords = screenToImageCoords(clientX, clientY);

        console.log('Pointer down - Screen:', screenX, screenY, 'Image:', imageCoords.x, imageCoords.y);

        if (currentMode === 'add') {
            startX = imageCoords.x;
            startY = imageCoords.y;
            
            currentBox = {
                startScreenX: screenX,
                startScreenY: screenY,
                width: 0,
                height: 0
            };
            isDrawing = true;
        } else if (currentMode === 'edit') {
            if (selectedBoxIndex !== -1) {
                const box = boundingBoxes[selectedBoxIndex];
                const screenCoords = imageToScreenCoords(box.x, box.y);
                const screenWidth = box.width / scaleX;
                const screenHeight = box.height / scaleY;
                const handles = getResizeHandles(screenCoords.x, screenCoords.y, screenWidth, screenHeight);
                
                for (let i = 0; i < handles.length; i++) {
                    if (isPointInHandle(screenX, screenY, handles[i])) {
                        resizeHandleIndex = i;
                        isResizing = true;
                        startX = imageCoords.x;
                        startY = imageCoords.y;
                        drawBoundingBoxes();
                        return;
                    }
                }
            }
            
            selectedBoxIndex = -1;
            for (let i = boundingBoxes.length - 1; i >= 0; i--) {
                const box = boundingBoxes[i];
                if (isPointInBox(screenX, screenY, box)) {
                    selectedBoxIndex = i;
                    isMoving = true;
                    startX = imageCoords.x;
                    startY = imageCoords.y;
                    updateSelectedInfo();
                    markUnsavedChanges();
                    break;
                }
            }
            drawBoundingBoxes();
        } else if (currentMode === 'delete') {
            for (let i = boundingBoxes.length - 1; i >= 0; i--) {
                const box = boundingBoxes[i];
                if (isPointInBox(screenX, screenY, box)) {
                    boundingBoxes.splice(i, 1);
                    selectedBoxIndex = -1;
                    updateSelectedInfo();
                    markUnsavedChanges();
                    break;
                }
            }
            drawBoundingBoxes();
        }
    }

    function handleMouseMove(e) {
        if (currentMode === 'view') return;
        handlePointerMove(e.clientX, e.clientY);
    }

    function handleTouchMove(e) {
        if (currentMode === 'view') return;
        e.preventDefault();
        const touch = e.touches[0];
        handlePointerMove(touch.clientX, touch.clientY);
    }

    function handlePointerMove(clientX, clientY) {
        const imgRect = parkingImage.getBoundingClientRect();
        const screenX = clientX - imgRect.left;
        const screenY = clientY - imgRect.top;
        const imageCoords = screenToImageCoords(clientX, clientY);

        if (currentMode === 'add' && currentBox && isDrawing) {
            currentBox.width = screenX - currentBox.startScreenX;
            currentBox.height = screenY - currentBox.startScreenY;
            drawBoundingBoxes();
        } else if (currentMode === 'edit' && selectedBoxIndex !== -1) {
            const box = boundingBoxes[selectedBoxIndex];
            
            if (isResizing) {
                const deltaX = imageCoords.x - startX;
                const deltaY = imageCoords.y - startY;
                
                switch (resizeHandleIndex) {
                    case 0: // top-left
                        box.x += deltaX;
                        box.y += deltaY;
                        box.width -= deltaX;
                        box.height -= deltaY;
                        break;
                    case 1: // top-right
                        box.y += deltaY;
                        box.width += deltaX;
                        box.height -= deltaY;
                        break;
                    case 2: // bottom-left
                        box.x += deltaX;
                        box.width -= deltaX;
                        box.height += deltaY;
                        break;
                    case 3: // bottom-right
                        box.width += deltaX;
                        box.height += deltaY;
                        break;
                }
                
                box.width = Math.max(20, box.width);
                box.height = Math.max(20, box.height);
                
                startX = imageCoords.x;
                startY = imageCoords.y;
                markUnsavedChanges();
                drawBoundingBoxes();
            } else if (isMoving) {
                const deltaX = imageCoords.x - startX;
                const deltaY = imageCoords.y - startY;
                box.x += deltaX;
                box.y += deltaY;
                startX = imageCoords.x;
                startY = imageCoords.y;
                markUnsavedChanges();
                drawBoundingBoxes();
            }
        }
    }

    function handleMouseUp() {
        handlePointerUp();
    }

    function handleTouchEnd() {
        handlePointerUp();
    }

    function handlePointerUp() {
        if (currentMode === 'add' && currentBox && isDrawing) {
            const endX = startX + (currentBox.width * scaleX);
            const endY = startY + (currentBox.height * scaleY);
            
            const finalWidth = Math.abs(endX - startX);
            const finalHeight = Math.abs(endY - startY);
            
            if (finalWidth > 20 && finalHeight > 20) {
                const normalizedBox = {
                    x: currentBox.width < 0 ? endX : startX,
                    y: currentBox.height < 0 ? endY : startY,
                    width: finalWidth,
                    height: finalHeight,
                    id: `P${boundingBoxes.length + 1}`
                };
                boundingBoxes.push(normalizedBox);
                markUnsavedChanges();
                console.log('Added box:', normalizedBox);
            }
            currentBox = null;
            isDrawing = false;
            drawBoundingBoxes();
        }
        
        isResizing = false;
        isMoving = false;
        resizeHandleIndex = -1;
    }

    function updateSelectedInfo() {
        if (selectedBoxIndex !== -1) {
            selectedInfo.classList.remove('hidden');
            selectedSlot.textContent = boundingBoxes[selectedBoxIndex].id;
        } else {
            selectedInfo.classList.add('hidden');
        }
    }

    function markUnsavedChanges() {
        hasUnsavedChanges = true;
        unsavedWarning.classList.remove('hidden');
    }

    function clearUnsavedChanges() {
        hasUnsavedChanges = false;
        unsavedWarning.classList.add('hidden');
    }

    function startEditing() {
        originalBoxes = JSON.parse(JSON.stringify(boundingBoxes));
        
        initialControls.classList.add('hidden');
        editingControls.classList.remove('hidden');
        instructions.classList.remove('hidden');
        modeIndicator.classList.remove('hidden');
        
        canvas.style.cursor = 'default';
        currentMode = 'edit';
        modeIndicator.textContent = 'Mode: Edit Parking Slot';
        
        switchToEditMode();
    }

    function switchToAddMode() {
        currentMode = 'add';
        modeIndicator.textContent = 'Mode: Add Parking Slot';
        canvas.style.cursor = 'crosshair';
        selectedBoxIndex = -1;
        updateSelectedInfo();
        drawBoundingBoxes();
    }

    function switchToEditMode() {
        currentMode = 'edit';
        modeIndicator.textContent = 'Mode: Edit Parking Slot';
        canvas.style.cursor = 'pointer';
        drawBoundingBoxes();
    }

    function switchToDeleteMode() {
        currentMode = 'delete';
        modeIndicator.textContent = 'Mode: Delete Parking Slot';
        canvas.style.cursor = 'not-allowed';
        selectedBoxIndex = -1;
        updateSelectedInfo();
        drawBoundingBoxes();
    }

    function saveChanges() {
        console.log('Saving parking slots:', boundingBoxes);
        
        Swal.fire({
            title: 'Success!',
            text: 'Parking slots have been saved successfully.',
            icon: 'success',
            confirmButtonText: 'OK'
        });
        
        clearUnsavedChanges();
        exitEditing();
    }

    function cancelEditing() {
        if (hasUnsavedChanges) {
            Swal.fire({
                title: 'Discard Changes?',
                text: 'You have unsaved changes. Are you sure you want to discard them?',
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Yes, Discard',
                cancelButtonText: 'Continue Editing'
            }).then((result) => {
                if (result.isConfirmed) {
                    boundingBoxes = JSON.parse(JSON.stringify(originalBoxes));
                    exitEditing();
                }
            });
        } else {
            exitEditing();
        }
    }

    function exitEditing() {
        initialControls.classList.remove('hidden');
        editingControls.classList.add('hidden');
        instructions.classList.add('hidden');
        modeIndicator.classList.add('hidden');
        selectedInfo.classList.add('hidden');
        unsavedWarning.classList.add('hidden');
        
        canvas.style.cursor = 'default';
        currentMode = 'view';
        
        selectedBoxIndex = -1;
        drawBoundingBoxes();
    }

    startEditBtn.addEventListener('click', startEditing);
    addButton.addEventListener('click', switchToAddMode);
    editButton.addEventListener('click', switchToEditMode);
    deleteButton.addEventListener('click', switchToDeleteMode);
    saveButton.addEventListener('click', saveChanges);
    cancelButton.addEventListener('click', cancelEditing);

    function initialize() {
        if (parkingImage.complete && parkingImage.naturalWidth > 0) {
            setCanvasSize();
        } else {
            parkingImage.addEventListener('load', function() {
                setTimeout(setCanvasSize, 100);
            });
        }
    }

    window.addEventListener('resize', function() {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(setCanvasSize, 100);
    });

    initialize();

    boundingBoxes = [];
});
</script>

<style>
#bounding-canvas {
    pointer-events: auto;
    touch-action: none;
}

#mode-indicator {
    z-index: 10;
}

#selected-info {
    z-index: 10;
}

/* Ensure image displays at full width */
#parking-image {
    max-width: 100%;
    height: auto;
    display: block;
}
</style>
{% endblock script %}